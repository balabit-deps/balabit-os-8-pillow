Backport of:

From 22e9bee4ef225c0edbb9323f94c26cee0c623497 Mon Sep 17 00:00:00 2001
From: Eric Soroos <eric-github@soroos.net>
Date: Sun, 7 Mar 2021 19:04:25 +0100
Subject: [PATCH] Fix DOS in PSDImagePlugin -- CVE-2021-28675

* PSDImagePlugin did not sanity check the number of input layers and
  vs the size of the data block, this could lead to a DOS on
  Image.open prior to Image.load.
* This issue dates to the PIL fork
---
 ...e28a249896e05b83840ae8140622de8e648ba9.psd | Bin 0 -> 555361 bytes
 ...8843abc37fc080ec36a2699ebbd44f795d3a6f.psd | Bin 0 -> 714605 bytes
 ...efc3fded6426986ba867a399791bae544f59bc.psd | Bin 0 -> 1004989 bytes
 ...dc7a4ebd856d79b4359bbcc79e8ef231ce38f6.psd | Bin 0 -> 592243 bytes
 Tests/test_decompression_bomb.py              |   1 +
 Tests/test_file_apng.py                       |   2 +-
 Tests/test_file_blp.py                        |   1 +
 Tests/test_file_psd.py                        |  15 ++++++++
 Tests/test_file_tiff.py                       |   7 ++--
 src/PIL/ImageFile.py                          |  14 ++++++--
 src/PIL/PsdImagePlugin.py                     |  32 ++++++++++++------
 11 files changed, 55 insertions(+), 17 deletions(-)
 create mode 100644 Tests/images/timeout-1ee28a249896e05b83840ae8140622de8e648ba9.psd
 create mode 100644 Tests/images/timeout-598843abc37fc080ec36a2699ebbd44f795d3a6f.psd
 create mode 100644 Tests/images/timeout-c8efc3fded6426986ba867a399791bae544f59bc.psd
 create mode 100644 Tests/images/timeout-dedc7a4ebd856d79b4359bbcc79e8ef231ce38f6.psd

--- a/Tests/test_decompression_bomb.py
+++ b/Tests/test_decompression_bomb.py
@@ -49,6 +49,7 @@ class TestDecompressionBomb(PillowTestCa
             with Image.open(TEST_FILE):
                 pass
 
+    @pytest.mark.xfail(reason="different exception")
     def test_exception_ico(self):
         with self.assertRaises(Image.DecompressionBombError):
             Image.open("Tests/images/decompression_bomb.ico")
--- a/Tests/test_file_blp.py
+++ b/Tests/test_file_blp.py
@@ -1,4 +1,5 @@
 from PIL import Image
+import pytest
 
 from .helper import PillowTestCase
 
--- a/Tests/test_file_tiff.py
+++ b/Tests/test_file_tiff.py
@@ -582,8 +582,10 @@ class TestFileTiff(PillowTestCase):
     @pytest.mark.filterwarnings("ignore:Possibly corrupt EXIF data")
     def test_string_dimension(self):
         # Assert that an error is raised if one of the dimensions is a string
-        with self.assertRaises(ValueError):
-            Image.open("Tests/images/string_dimension.tiff")
+        with pytest.raises(OSError):
+            with Image.open("Tests/images/string_dimension.tiff") as im:
+                im.load()
+
 
 
 @unittest.skipUnless(is_win32(), "Windows only")
--- a/src/PIL/ImageFile.py
+++ b/src/PIL/ImageFile.py
@@ -541,12 +541,18 @@ def _safe_read(fp, size):
 
     :param fp: File handle.  Must implement a <b>read</b> method.
     :param size: Number of bytes to read.
-    :returns: A string containing up to <i>size</i> bytes of data.
+    :returns: A string containing <i>size</i> bytes of data.
+
+    Raises an OSError if the file is truncated and the read can not be completed
+
     """
     if size <= 0:
         return b""
     if size <= SAFEBLOCK:
-        return fp.read(size)
+        data = fp.read(size)
+        if len(data) < size:
+            raise OSError("Truncated File Read")
+        return data
     data = []
     while size > 0:
         block = fp.read(min(size, SAFEBLOCK))
@@ -554,9 +560,13 @@ def _safe_read(fp, size):
             break
         data.append(block)
         size -= len(block)
+    if sum(len(d) for d in data) < size:
+        raise OSError("Truncated File Read")
     return b"".join(data)
 
 
+
+
 class PyCodecState:
     def __init__(self):
         self.xsize = 0
--- a/src/PIL/PsdImagePlugin.py
+++ b/src/PIL/PsdImagePlugin.py
@@ -117,7 +117,8 @@ class PsdImageFile(ImageFile.ImageFile):
             end = self.fp.tell() + size
             size = i32(read(4))
             if size:
-                self.layers = _layerinfo(self.fp)
+                _layer_data = io.BytesIO(ImageFile._safe_read(self.fp, size))
+                self.layers = _layerinfo(_layer_data, size)
             self.fp.seek(end)
 
         #
@@ -174,12 +175,20 @@ class PsdImageFile(ImageFile.ImageFile):
         finally:
             self.__fp = None
 
-
-def _layerinfo(file):
+def _layerinfo(fp, ct_bytes):
     # read layerinfo block
     layers = []
-    read = file.read
-    for i in range(abs(i16(read(2)))):
+
+    def read(size):
+        return ImageFile._safe_read(fp, size)
+
+    ct = i16(read(2))
+
+    # sanity check
+    if ct_bytes < (abs(ct) * 20):
+        raise SyntaxError("Layer block too short for number of layers requested")
+
+    for i in range(abs(ct)):
 
         # bounding box
         y0 = i32(read(4))
@@ -190,7 +199,8 @@ def _layerinfo(file):
         # image info
         info = []
         mode = []
-        types = list(range(i16(read(2))))
+        ct_types = i16(read(2))
+        types = list(range(ct_types))
         if len(types) > 4:
             continue
 
@@ -223,16 +233,16 @@ def _layerinfo(file):
         size = i32(read(4))  # length of the extra data field
         combined = 0
         if size:
-            data_end = file.tell() + size
+            data_end = fp.tell() + size
 
             length = i32(read(4))
             if length:
-                file.seek(length - 16, io.SEEK_CUR)
+                fp.seek(length - 16, io.SEEK_CUR)
             combined += length + 4
 
             length = i32(read(4))
             if length:
-                file.seek(length, io.SEEK_CUR)
+                fp.seek(length, io.SEEK_CUR)
             combined += length + 4
 
             length = i8(read(1))
@@ -242,7 +252,7 @@ def _layerinfo(file):
                 name = read(length).decode("latin-1", "replace")
             combined += length + 1
 
-            file.seek(data_end)
+            fp.seek(data_end)
         layers.append((name, mode, (x0, y0, x1, y1)))
 
     # get tiles
@@ -250,7 +260,7 @@ def _layerinfo(file):
     for name, mode, bbox in layers:
         tile = []
         for m in mode:
-            t = _maketile(file, m, bbox, 1)
+            t = _maketile(fp, m, bbox, 1)
             if t:
                 tile.extend(t)
         layers[i] = name, mode, bbox, tile
