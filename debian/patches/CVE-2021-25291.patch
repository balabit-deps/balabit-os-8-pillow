From cbdce6c5d054fccaf4af34b47f212355c64ace7a Mon Sep 17 00:00:00 2001
From: Eric Soroos <eric-github@soroos.net>
Date: Sat, 23 Jan 2021 11:36:50 +0100
Subject: [PATCH] Fix for CVE-2021-25291

* Invalid tile boundaries lead to OOB Read in TiffDecode.c, in TiffReadRGBATile
* Check the tile validity before attempting to read.
---
 ...-63b1dffefc8c075ddc606c0a2f5fdc15ece78863.tif | Bin 0 -> 3728 bytes
 Tests/test_tiff_crashes.py                       |   1 +
 src/libImaging/TiffDecode.c                      |   9 +++++++++
 3 files changed, 10 insertions(+)
 create mode 100644 Tests/images/crash-63b1dffefc8c075ddc606c0a2f5fdc15ece78863.tif

--- a/src/libImaging/TiffDecode.c
+++ b/src/libImaging/TiffDecode.c
@@ -468,6 +468,15 @@ int ImagingLibTiffDecode(Imaging im, Ima
 
         for (y = state->yoff; y < state->ysize; y += tile_length) {
             for (x = state->xoff; x < state->xsize; x += tile_width) {
+                /* Sanity Check. Apparently in some cases, the TiffReadRGBA* functions
+                   have a different view of the size of the tiff than we're getting from
+                   other functions. So, we need to check here. 
+                */
+                if (!TIFFCheckTile(tiff, x, y, 0, 0)) {
+                    TRACE(("Check Tile Error, Tile at %dx%d\n", x, y));
+                    state->errcode = IMAGING_CODEC_BROKEN;
+                    goto decode_err;
+                }
                 if (isYCbCr) {
                     /* To avoid dealing with YCbCr subsampling, let libtiff handle it */
                     if (!TIFFReadRGBATile(tiff, x, y, (UINT32 *)state->buffer)) {
